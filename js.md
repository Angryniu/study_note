# JS核心技术
* 原型与原型链
* 执行上下文
* 执行上下文栈
* 变量提升
* 函数提升
* 作用域与作用域链
* 闭包
* 对象的多种创建模式
* 对象的继承模式
* javaScript事件循环机制


# 数据类型
## 分类  基本数据类型 和 引用数据类型
* 基本数据类型包括:string、number、boolean、null、undefined、symbol(es6)
* 引用数据类型包括:Object、function、Array
## 判断 typeof instanceof  ===
* typeof: 判断 undefined/数值/字符串/布尔值
         不能判断 null与object object与array
* instanceof(实例):判断对象的具体类型(是Object/Function/Array)
* ===: 判断 undefined/null
## 相关问题
### undefined 与 null的区别
* undefined代表定义未赋值
* null 代表定义并赋值null
### 什么时候给变量赋值为null？
* 初始赋值，表明将要赋值为对象
* 结束前，让对象成为垃圾对象(被垃圾回收器回收)
### 严格区分变量类型与数据类型
 var  c = []  当值为数组 是 对象类型
              此时变量(存的地址值)为   引用类型
* 数据类型  分为 基本类型 对象类型
* 变量类型(变量内存值的类型)  分为 基本类型 引用类型
## 数据、变量、内存
### 什么是数据
* 存储在内存中代表特定信息的数据，本质上是0101...
### 什么是内存
* 内存条通电后产生的可存储数据的空间(临时的,要通电)

# 对象
## 什么是对象
* 多个数据的封装体
* 用来保存多个数据的容器
* 一个对象代表现实世界中的一个事物
## 为什么要用对象？
* 统一管理多个数据
## 对象的组成
* 属性: 属性名(字符串)和属性值(任意类型)组成
* 方法: 一种特别的属性(属性值是函数)
## 如何访问对象内部数据？
* 对象名.属性名:编码简单，有时不能使用
* 对象名['属性名']:编码麻烦，能通用
* 对象名.方法名()
### 什么时候使用 对象名['属性名']
* 属性名包含特殊字符:- 空格
* 变量名不确定

# 函数
## 什么是函数
* 实现特定功能的n条语句的封装体
* 只有函数是可以执行的，其它类型的数据不能执行
## 为什么要用函数
* 提高代码复用
* 便于阅读交流
## 如何定义函数？
* 函数声明  function 函数名(){}
* 表达式   var  a = function(){}
## 如何调用(执行)函数
* test(): 直接调用
* obj.test(): 通过对象调用
* new test(): new调用
* test.call/apply(obj):临时让test成为obj的方法进行调用 ---可以让一个函数成为指定任意对象的方法进行调用
## 什么函数才是回调函数
* 自己定义的
* 没有调
* 自己执行了
## 常见的回调函数
* dom事件回调函数
* 定时器回调函数
* ajax请求回调函数
* 生命周期回调函数

## IIFE(立即执行函数) ---匿名函数自调用
### (function(){})()
### 作用
* 隐藏实现--变量声明函数内
* 不会污染全局命名空间

# this
## this是什么
* 任何函数本质上都是通过某个对象来调用的
* 全局中的this 是 window
* 所有函数内部都有一个变量this
* 它的值是调用函数的当前对象
## 如何确定this的值
* test() : window
* p.test(): p
* new test(): 新创建的对象
* p.call(obj): obj

# 函数的prototype(指向的空对象为原型对象)
## 函数的prototype属性
* 每个函数都一个prototype属性，它默认指向一个Object空对象(即称为:原型对象)
* 给原型对象添加属性方法，供其实例化对象去调用
* 原型对象中有一个属性constructor,它指向函数对象
## 显式原型与隐式原型
* 每个函数都有prototype属性，即为显式原型
* 每个实例对象都有一个__proto__,为隐式原型
* 实例对象的隐式原型的值为其对应构造函数的显式原型的值
* 函数的prototype属性:在定义函数时自动添加的,默认值是一个空Object对象
* 对象的__proto__属性:创建实例化对象时自动添加，默认值为构造函数的
* 程序员可以直接操作显式原型，但不能直接操作隐式原型
## 原型链
* 访问一个对象的属性时，先查找自身属性，找到返回。如果没有，再沿着__proto__这条链向上查找，找到返回，如果没找到返回undefined
* 别名:隐式原型链
* 作用:查找对象的属性(方法)
* 函数的显式原型指向的对象默认是空Object实例对象(Object不满足)
* 所有函数都是Function的实例(new Function)
* Object的原型对象是原型链尽头
* 读取对象的属性值时,会自动到原型链中查找
* 设置对象的属性值时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值
* 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上
## 原型继承
* 构造函数的实例对象自动拥有构造函数原型对象的属性(方法)
* 利用的就是原型链


## instanceof
* 表达式: A instanceof B
* 如果B函数的显式原型对象在A对象的原型链上,返回true，否则返回false

# 执行上下文与执行上下文栈
## 变量提升与函数提升()
### 变量提升
* 通过var定义(声明)的变量，在定义语句之前就可以访问到
* 值: undefined
### 函数提升
* 通过function声明的函数，在之前就可以直接调用
* 值: 函数定义(对象)
### 函数声明提升优先于变量声明提升
* 函数声明不会被变量声明覆盖，但是会被变量赋值覆盖


## 执行上下文
### 代码分类(位置)
* 全局代码
* 函数(局部)代码
### 全局执行上下文
* 在执行全局代码前将window确定为全局执行上下文
* 对全局数据进行预处理
  * var定义的全局变量===>undefined，添加为window的属性
  * function声明的全局函数===> 赋值(fun),添加为window的方法
  * this===>赋值(window)
* 开始执行全局代码
### 函数执行上下文
* 在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象
* 对局部数据进行预处理
  * 形参变量===>赋值(实参)===>添加为执行上下文的属性
  * arguments===>赋值(实参列表),添加为执行上下文的属性
  * var定义的局部变量===>undefined，添加为执行上下文的属性
  * function声明的函数===>赋值(fun),添加为执行上下文的方法
  * this===>赋值(调用函数的对象)
  * 开始执行代码
### 执行上下文栈
* 在全局代码执行前,JS引擎就会创建一个栈来储存管理所有的执行上下文对象
* 在全局执行上下文(window)确定后，将其添加到栈中(压栈)
* 在函数执行上下文创建后，将其添加到栈中(压栈)
* 在当前函数执行完成后，将栈顶的对象移除(出栈)
* 当所有的代码执行完后，栈中只剩下window

# 作用域与作用域链
## 理解作用域
* 一个代码所在的区域,它是静态的(相当于上下文对象),在编写代码时就确定的
## 作用域分类
* 全局作用域、函数作用域、块作用域
## 作用
* 隔离变量。不同作用域下同名变量不会冲突
## 作用域与执行上下文区别
### 区别1
* 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时。
* 全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建
* 函数执行上下文环境是在调用函数时，函数体代码执行之前创建
### 区别2
* 作用域是静态的，只要函数定义好就一直存在，且不会再变化
* 执行上下文环境是动态的，调用函数时创建，函数调用结束时就会自动释放
### 联系
* 执行上下文环境(对象)是从属于所在的作用域
* 全局上下文环境===>全局作用域
* 函数上下文环境===>对应的函数使用域
## 作用域链
### 理解
* 多个上下级关系的作用域形成的链，它的方向是从下向上的(从内到外)
* 查找变量时就是沿着作用域链来查找的
### 查找一个变量的查找规则
* 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入上一层作用域2
* 在上一层作用域2的执行上下文中查找对应的属性，如果有直接返回，否则进入上一层作用域3
* 再次执行2的相同操作，直到全局作用域，如果还找不到就抛出找不到的异常

# 闭包
## 如何产生闭包
* 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，产生了闭包
## 闭包到底是什么
* 使用chrome调试查看
* 理解一: 闭包是嵌套的内部函数
* 理解二：包含被引用变量(函数)的对象
* 注意: 闭包存在于嵌套的内部函数中
## 产生闭包的条件
* 嵌套函数
* 内部函数引用了外部函数的数据(变量/函数)
## 常见的闭包
* 将函数作为另一个函数的返回值
* 将函数作为实参传递给另一个函数调用
## 闭包的作用
* 使用函数内部的变量在函数执行完后，仍然存在内存中(延长局部变量的生命周期)
* 让函数外部可以操作(读写)到函数内部的数据(变量/函数)
## 闭包的生命周期
* 产生:在嵌套内部函数定义执行完时就产生了(不是在调用)
* 死亡:在嵌套内部函数成为垃圾对象时(内部函数=null)
## 闭包的应用-自定义JS模块
* 具有特定功能的js文件
* 将所有的数据和功能都封装在一个函数内部(私有的)
* 向外暴露一个包含n个方法的对象或函数
* 模块的使用者，只需要通过模块暴露对象调用方法来实现对应的功能
## 闭包的缺点及解决
### 缺点
* 函数执行完后，函数内的局部变量没有释放，占用内存时间会变成
* 容易造成内存泄漏
### 解决
* 能不用闭包就不用闭包
* 及时释放(内部函数=null 成为垃圾对象)
## 内存溢出与内存泄漏
### 内存溢出
* 一种程序运行出现的错误
* 当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误
### 内存泄露
* 占有的内存没有及时释放
* 内存泄露积累多了就容易导致内存溢出
* 常见的内存泄露
  * 意外的全局变量(函数局部作用域，声明变量没有用关键词 a=2)
  * 没有及时清理的计时器或回调函数
  * 闭包


# 面向对象高级
## 对象创建模式
### Object构造函数模式
* 先创建Object对象，再动态添加属性/方法
  eg: let obj = new Object()  obj.name='张三' obj.mes = function(){}
* 适用场景:起始时不确定对象内部数据
* 问题:语句太多
### 对象字面量模式
* 使用{}创建对象,var obj = {}  同时指定属性/方法
* 适用场景:起始时对象内部数据是确定的
* 问题:如果创建多个对象,有重复代码
### 工厂模式
* 通过工厂函数动态创建对象并返回  function Person(){var obj={name:name}}
* 适用场景: 需要创建多个对象
* 问题: 对象没有一个具体的类型，都是Object类型
### 自定义构造函数模式
* 自定义构造函数，通过new创建对象
* 适用场景:需要创建多个类型确定的对象
* 问题: 每个对象都有相同的数据，浪费内存
### 构造函数+原型的组合模式
* 自定义构造函数，属性在函数中初始化，方法添加到原型上
* 适用场景:需要创建多个类型确定的对象

# 继承模式
## 原型链继承
* 定义父类型函数
* 给父类型的原型添加方法
* 定义子类型的构造函数
* 创建父类型的对象赋值给子类型的原型
  子.prototype = new 父()
* 将子类型原型的构造函数属性设置为子类型
   子.prototype.constructor = 子
* 给子类型原型添加方法
* 创建子类型的对象；可以调用父类型的方法

* 子类型的原型为父类型的一个实例对象

## 借用构造函数继承
* 定义父类型构造函数
* 定义子类型构造函数
* 在子类型构造函数中调用父类型构造

* 在子类型构造函数中通用父.call()调用父类型构造函数

## 原型链+借用构造函数的组合继承
* 利用原型链实现对父类型对象的方法继承
* 利用call()借用父类型构造函数初始化相同属性

# 进程与线程
## 进程
* 程序的一次执行,它占有一片独有的内存空间
* 可以通过windows任务管理器查看进程
## 线程
* 是进程的一个独立执行单元
* 是程序执行的一个完成的流程
* 是CPU最小的调度单元
## 相关知识
* 应用程序必须运行在某个进程的某个线程上
* 一个进程中至少有一个运行的线程:主线程，进程启动后自动创建
* 一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的
* 一个进程内的数据可以供其中的多个线程直接共享
* 多个进程之间的数据是不能直接共享的
* 线程池:保存多个线程对象的容器，实现线程对象的反复利用
## 何为多进程与多线程
* 多进程:一应用程序可以同时启动多个实例运行
* 多线程:在一个进程内，同时有多个线程运行
## 比较单线程与多线程
* 多线程:有效提升CPU的利用率
* 单线程:顺序变成简单易懂
## Js是单线程
* js是单线程，但使用web workers可以多线程运行

# 浏览器内核(浏览器的内核代码,里面有众多模块来执行页面一系列操作)
## 支撑浏览器运行的最核心的程序
## 不同的浏览器的内核可能不一样
## 内核由很多模块组成
### 主线程
* js引擎模块:负责js程序的编译与运行
* html、css文档解析模块:负责页面文本的解析
* DOM/CSS模块:负责dom/css在内存中的相关处理
* 布局和渲染模块:负责页面的布局和效果的绘制(内存中的对象)
### 分线程
* 定时器模块:负责定时器的管理
* DOM事件响应模块:负责事件的管理
* 网络请求模块:负责ajax请求
## js是单线程的
* setTimeout()回调函数是在主线程执行的
* 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行
## js引擎执行代码的基本流程
* 先执行初始化代码:包含一些特别的代码
 * 设置定时器
 * 绑定监听
 * 发送ajax请求
* 后面某个时刻才会执行回调代码
## 事件循环模型
### 所有代码的分类
* 初始化代码(同步):包含绑定dom事件监听，设置定时器，发送ajax请求
* 回调执行代码(异步):处理回调逻辑
### 模型的2个重要组成部分
* 事件(定时器/DOM事件/ajax)管理模块
* 回调队列
### 模型的运转流程
* 执行初始化代码，将事件回调函数交给对应模块管理
* 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中
* 只有当初始化代码执行完后,才会遍历读取回调队列中的回调函数执行
### 重要概念
* 执行栈(execution stack):所有代码都在此空间执行
* 浏览器内核(browser core):js引擎模块(主线程)、其它模块(主/分线程)
* 任务队列(回调队列分支)
* 消息队列(回调队列分支)
* 事件队列(回调队列分支)
* 事件轮询(event loop):从任务队列中循环取出回调函数放入执行栈中处理(一个一个处理)
* 事件驱动模型
* 请求响应模型

# js基础
## DOM事件流
* 事件流描述的是从页面中接收事件的顺序
* 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流
* DOM事件流分为三个阶段:捕获阶段(从上到下)、当前目标阶段、冒泡阶段(从下到上)
* 有些事件没有冒泡:onblur、onfocus、onmouseenter、onmouseleave
* onclick只能得到冒泡阶段
## 事件对象
* event是一个事件对象,写到侦听函数的小括号里,当形参看
* 事件对象只有有了事件才会存在,它是系统给我们自动创建的,不需要我们传递参数
* 事件对象是事件一系列相关数据(属性方法)的集合
## 事件委派
* 将事件添加到其父节点，利用冒泡原理影响设置每个子节点

# DOM(Document Object Model) 文档对象模型，处理可拓展标记语言的标准编程接口
## DOM树包括
* 文档(一个页面就是一个文档，DOM中使用document表示)
* 元素(所有标签就是元素)
* 节点(所有内容都是节点(标签、属性) dom中用node表示)

## 事件三要素--事件源 事件类型 事件处理程序
* 事件源 (事件被触发的对象 获取)
* 事件类型 (如何触发 什么事件 ps:鼠标点击 鼠标经过 键盘按下)
* 事件处理程序(通过一个函数赋值的方式完成)
* 1.获取事件源 2.绑定事件(注册事件) 3.添加事件


## 元素   
### 获取元素
* 通过id  document.getElementById("id名")
* 通过标签名  document.getElementsByTagName("标签名")
* 通过类名    document.getElementByClassName('类名')
* 通过选择器  document.querySelector()   document.querySelectorAll()
* 获取特殊元素body  document.body()
* 获取特殊元素html  document.documentElement()

### 操作元素
#### 改变元素内容 比如div标签里面的内容
* innerText 不识别HTML标签 非标准 去除空格和换行
* innerHTML 识别HTML标签
###  修改元素属性
* element.注册事件(onclick) = function(){}
* element.setAttribute()  创建自定义属性
* element.属性             获取内置属性
* element.getAttribute('属性')  获取自定义属性
* element.属性= 修改内容
* element.removeAttribute('属性') 移除属性
### 修改表单属性
* input.value  input.type  input.checked input.selected input.disabled(为true时，不能二次触发)
### 修改样式属性
* element.style = 'color:pink' 行内样式操作
* element.style.color = 'pink' 外联样式操作
* element.className = ''  修改样式名

## 节点
### 获取节点
* 节点至少拥有nodeType(节点类型)、nodeName(节点名称)和nodeValue(节点值)
* 父级节点parentNode    element.parentNode
* 子级节点children(非标准)   firstElementChild lastElementChild    element.children --得到数组   
* 兄弟节点  nextSibling 下一个兄弟节点    previousSibling 上一个兄弟节点  
* 兄弟节点  nextElementSibling 下一个兄弟元素节点  previousElementSibling 上一个兄弟元素节点 
### 操作节点
#### 创建节点
* document.write('文本/<p>我是元素</p>')
* element.innerHTML(文本+标签)
* element.innerTEXT(文本)
* element.createElement('tagName')
### 添加
* node.appendChild(child) 后面追加子节点
* node.insertBefore(child,指定元素) 插入到指定元素前面
### 删除
* node.removeChild(child)
### 添加浅拷贝  node.cloneNode()   括号为true 深拷贝 复制节点本身以及里面的所有子节点

## 事件高级
### 注册事件(绑定事件)
* 传统方式: 利用on开头的事件 onclick
* 方法监听注册方式  addEventListener
### 事件流理论
* 事件流描述从页面接收事件的顺序
* onclick attachevent 只能到冒泡阶段
* 事件流分为3个阶段   捕获阶段、当前目标阶段、冒泡阶段

### 事件对象
* event对象代表事件(onclick等)的状态，事件发生后，跟事件相关的一系列信息数据的集合，都放到对象里面，包括属性和方法
### 事件委托
* 也称事件代理
* 原理:每个子节点不用单独设置事件监听器，而是设置到其父节点，利用冒泡原理影响设置每个子节点
* 只操作一次DOM,提高程序的性能

# BOM(Browser Object Model) 浏览器对象模型
## 窗口事件
## 两种定时器定时器
* setTimeout(调用函数，[延迟毫秒数ms])    等一会儿再调用，只调用一次
* setInterval(调用函数，[延迟毫秒数ms])   每个一段时间就调用
* clearTimeout(timeout)
* clearInterval(interval)
# "use strict" 不是一条语句,是一个字面量表达式  严格模式
## 目的:指定代码在严格条件下执行
* 消除代码运行的一些不安全之处,保证代码运行的安全
* 提高编译器效率,增加运行速度
* 为未来新版本的javascript做好铺垫

### 严格模式的限制
* 不允许使用未声明的变量
* 不允许删除变量或对象或函数
* 不允许变量重名
* 不允许使用八进制
* 不允许使用转义符
* 不允许对只读属性赋值
* 不允许对一个使用getter方法读取的属性进行赋值
* 不允许删除一个不允许删除的属性
* 不能使用arguments字符串
* 禁止this指向全局对象

### 新增保留关键字
* let public  static

### 'use strict'指令只允许出现在脚本或函数的开头




# Lodash插件
* 里面封装函数的防抖与节流的业务[闭包+延迟器]
* lodash函数库对外暴露 _函数
## 节流(操作的间隔大于规定的间隔才会去触发)
* 在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
* _.throttle(节流函数,触发时间)       当前时间 - 上次触发时间  大于间隔时间
## 防抖(前面的请求全部取消，只发最后一次)
* 前面的所有的触发都被取消，最后一次被执行在规定的时间之后才会触发，也就是说如果连续快速触发，只会执行一次
* _.debounce(防抖的函数,触发时间)      清除上一次定时器，设置定时器  一直点一直清除



